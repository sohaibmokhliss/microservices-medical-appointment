\chapter{Tests et Validation}

\section{Introduction}

Ce chapitre présente la stratégie de tests mise en œuvre pour garantir la qualité et la fiabilité du système. Nous décrivons les différents types de tests réalisés (unitaires, d'intégration, de résilience) et les résultats obtenus.

\section{Stratégie de Tests}

\subsection{Pyramide de tests}

Notre stratégie de tests suit la pyramide de tests classique :

\begin{itemize}
    \item \textbf{Tests unitaires} (base) : Nombreux, rapides, testant des composants isolés
    \item \textbf{Tests d'intégration} (milieu) : Moins nombreux, testant l'interaction entre composants
    \item \textbf{Tests end-to-end} (sommet) : Peu nombreux, testant les scénarios utilisateur complets
\end{itemize}

\subsection{Outils de test}

\begin{itemize}
    \item \textbf{JUnit 5} : Framework de tests unitaires pour Java
    \item \textbf{Mockito} : Framework de mock pour isoler les dépendances
    \item \textbf{Spring Boot Test} : Outils de test pour applications Spring
    \item \textbf{TestContainers} : Conteneurs Docker pour tests d'intégration (PostgreSQL, RabbitMQ)
    \item \textbf{REST Assured} : Tests d'API REST
    \item \textbf{Jest/React Testing Library} : Tests du frontend React
\end{itemize}

\section{Tests Unitaires}

\subsection{Tests des services métier}

\subsubsection{Auth Service}

\textbf{AuthService - Tests de l'inscription :}
\begin{itemize}
    \item Test d'inscription réussie avec données valides
    \item Test de rejet si email déjà existant
    \item Test de validation des données (email invalide, mot de passe trop court)
    \item Test de chiffrement du mot de passe (vérification BCrypt)
\end{itemize}

\textbf{AuthService - Tests de l'authentification :}
\begin{itemize}
    \item Test de connexion réussie avec credentials valides
    \item Test de rejet avec mot de passe incorrect
    \item Test de rejet avec email inexistant
    \item Test de génération du JWT avec les claims appropriés
\end{itemize}

\textbf{JwtService - Tests de gestion des tokens :}
\begin{itemize}
    \item Test de génération de token avec user valide
    \item Test d'extraction de l'email depuis le token
    \item Test de validation de token valide
    \item Test de rejet de token expiré
    \item Test de rejet de token avec signature invalide
\end{itemize}

\subsubsection{Docteur Service}

\textbf{DocteurService - Tests CRUD :}
\begin{itemize}
    \item Test de création d'un médecin avec données valides
    \item Test de récupération de tous les médecins
    \item Test de récupération d'un médecin par ID
    \item Test de mise à jour d'un médecin existant
    \item Test de suppression d'un médecin
    \item Test de gestion d'erreur pour médecin inexistant
\end{itemize}

\subsubsection{RDV Service}

\textbf{RdvService - Tests de création :}
\begin{itemize}
    \item Test de création réussie avec médecin existant
    \item Test de rejet si médecin inexistant (via mock Feign)
    \item Test de validation de date (rejet si date passée)
    \item Test de publication d'événement RabbitMQ après création
    \item Test de gestion du Circuit Breaker si Docteur Service indisponible
\end{itemize}

\textbf{RdvService - Tests de mise à jour :}
\begin{itemize}
    \item Test de mise à jour réussie d'un rendez-vous existant
    \item Test de publication d'événement après mise à jour
    \item Test de rejet si rendez-vous inexistant
\end{itemize}

\subsubsection{Billing Service}

\textbf{InvoiceService - Tests de génération :}
\begin{itemize}
    \item Test de génération automatique de facture depuis événement RDV
    \item Test de génération du numéro de facture unique (format INV-YYYY-XXXXX)
    \item Test de calcul du montant depuis Pricing
    \item Test de publication d'événement après création de facture
\end{itemize}

\textbf{PaymentService - Tests d'enregistrement :}
\begin{itemize}
    \item Test d'enregistrement d'un paiement complet
    \item Test d'enregistrement d'un paiement partiel
    \item Test de mise à jour du statut de facture si paiement complet
    \item Test de calcul du solde restant
    \item Test de publication d'événement après paiement confirmé
\end{itemize}

\subsection{Tests des repositories}

\textbf{Tests Spring Data JPA :}
\begin{itemize}
    \item Tests des méthodes custom (ex : \texttt{findByEmail} dans UserRepository)
    \item Tests des requêtes avec critères
    \item Tests de la persistance et de l'intégrité référentielle
    \item Utilisation de \texttt{@DataJpaTest} avec base H2 en mémoire
\end{itemize}

\subsection{Couverture des tests unitaires}

\begin{table}[H]
\centering
\caption{Couverture de tests par service}
\label{tab:coverage}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Service} & \textbf{Couverture (\%)} & \textbf{Nombre de tests} \\
\hline
Auth Service & 85\% & 32 \\
\hline
Docteur Service & 90\% & 18 \\
\hline
RDV Service & 82\% & 28 \\
\hline
Billing Service & 80\% & 35 \\
\hline
Notification Service & 75\% & 15 \\
\hline
\textbf{Moyenne} & \textbf{82\%} & \textbf{128} \\
\hline
\end{tabular}
\end{table}

\section{Tests d'Intégration}

\subsection{Tests d'API REST}

\textbf{Approche :}
\begin{itemize}
    \item Utilisation de \texttt{@SpringBootTest} avec \texttt{webEnvironment = RANDOM\_PORT}
    \item TestContainers pour PostgreSQL et RabbitMQ
    \item REST Assured pour les assertions sur les réponses HTTP
\end{itemize}

\subsubsection{Scénarios de test}

\textbf{Auth Service :}
\begin{itemize}
    \item POST /api/auth/register → Vérification du statut 201 et du contenu de réponse
    \item POST /api/auth/login → Vérification du JWT retourné et de sa validité
    \item GET /api/auth/validate → Validation d'un token valide vs invalide
    \item GET /api/users (avec token Admin) → Vérification de la liste
    \item GET /api/users (sans token) → Vérification du statut 401
\end{itemize}

\textbf{RDV Service :}
\begin{itemize}
    \item POST /api/rdv → Création et vérification de l'événement RabbitMQ publié
    \item GET /api/rdv → Vérification de la liste de rendez-vous
    \item PUT /api/rdv/\{id\} → Modification avec token valide
    \item DELETE /api/rdv/\{id\} → Annulation avec vérification de l'événement
\end{itemize}

\subsection{Tests de communication inter-services}

\textbf{RDV Service → Docteur Service (Feign) :}
\begin{itemize}
    \item Test de l'appel Feign réussi avec médecin existant
    \item Test de gestion d'erreur si médecin inexistant (404)
    \item Test du Circuit Breaker si Docteur Service ne répond pas
    \item Utilisation de WireMock pour simuler les réponses du Docteur Service
\end{itemize}

\subsection{Tests de messaging asynchrone}

\textbf{RabbitMQ - Publication et consommation :}
\begin{itemize}
    \item Test de publication d'événement depuis RDV Service
    \item Test de réception d'événement par Notification Service
    \item Test de réception d'événement par Billing Service
    \item Vérification de la persistance des messages dans RabbitMQ
    \item Test de traitement en cas de rejet (dead letter queue)
\end{itemize}

\textbf{Scénario complet :}
\begin{enumerate}
    \item Création d'un rendez-vous via API
    \item Vérification de la persistance dans rdvdb
    \item Vérification de la publication dans RabbitMQ
    \item Attente de la consommation par Billing Service
    \item Vérification de la création de facture dans billingdb
    \item Vérification de l'envoi d'email (mock de Resend API)
\end{enumerate}

\section{Tests de Résilience}

\subsection{Tests du Circuit Breaker}

\textbf{Configuration de test :}
\begin{itemize}
    \item Seuil d'ouverture : 50\% d'échecs sur 10 requêtes
    \item Durée d'ouverture : 60 secondes
    \item Taille du ring buffer : 10 requêtes
\end{itemize}

\textbf{Scénarios testés :}

\paragraph{Scénario 1 : Ouverture du circuit}
\begin{enumerate}
    \item Simuler l'indisponibilité du Docteur Service
    \item Envoyer 10 requêtes de création de rendez-vous
    \item Vérifier que 50\% échouent (seuil atteint)
    \item Vérifier que le circuit s'ouvre
    \item Vérifier que les requêtes suivantes échouent immédiatement (fail-fast)
    \item Vérifier le message d'erreur approprié
\end{enumerate}

\paragraph{Scénario 2 : Récupération du service}
\begin{enumerate}
    \item Circuit ouvert suite aux échecs
    \item Attendre la durée d'ouverture (60s)
    \item Vérifier que le circuit passe en état semi-ouvert
    \item Réactiver le Docteur Service
    \item Envoyer des requêtes test
    \item Vérifier que le circuit se referme progressivement
    \item Vérifier le retour à la normale
\end{enumerate}

\subsection{Tests de Retry}

\textbf{Configuration de test :}
\begin{itemize}
    \item Nombre de tentatives : 3
    \item Délai entre tentatives : 1 seconde
    \item Backoff exponentiel : x2 à chaque tentative
\end{itemize}

\textbf{Scénarios testés :}
\begin{itemize}
    \item Simulation d'erreur réseau temporaire (timeout)
    \item Vérification des 3 tentatives de retry
    \item Vérification de l'augmentation du délai (1s, 2s, 4s)
    \item Succès à la 2ème tentative (erreur transitoire résolue)
    \item Échec après les 3 tentatives (erreur permanente)
\end{itemize}

\subsection{Tests de Timeout}

\textbf{Configuration de test :}
\begin{itemize}
    \item Timeout configuré : 5 secondes
\end{itemize}

\textbf{Scénarios testés :}
\begin{itemize}
    \item Simulation d'un service lent (réponse après 6 secondes)
    \item Vérification du timeout après 5 secondes
    \item Vérification de l'exception TimeoutException
    \item Vérification que la requête est bien abandonnée
\end{itemize}

\section{Tests de Validation Fonctionnelle}

\subsection{Tests manuels}

Des tests manuels ont été réalisés pour valider les scénarios utilisateurs complets :

\subsubsection{Scénario 1 : Prise de rendez-vous par un patient}
\begin{enumerate}
    \item Accéder à la page d'accueil
    \item Consulter la liste des médecins disponibles
    \item Remplir le formulaire de prise de rendez-vous
    \item Soumettre le formulaire
    \item Vérifier le message de confirmation
    \item Vérifier la réception de l'email de confirmation
    \item Vérifier la présence du rendez-vous dans la liste
    \item Vérifier la création de la facture associée
\end{enumerate}

\textbf{Résultat :} ✓ Réussi

\subsubsection{Scénario 2 : Gestion des médecins par l'administrateur}
\begin{enumerate}
    \item Se connecter en tant qu'administrateur
    \item Accéder à la page de gestion des médecins
    \item Ajouter un nouveau médecin
    \item Modifier un médecin existant
    \item Vérifier les modifications dans la liste
    \item Supprimer un médecin
    \item Vérifier la suppression
\end{enumerate}

\textbf{Résultat :} ✓ Réussi

\subsubsection{Scénario 3 : Gestion de la facturation par le réceptionniste}
\begin{enumerate}
    \item Se connecter en tant que réceptionniste
    \item Accéder à la page de facturation
    \item Consulter la liste des factures
    \item Sélectionner une facture en attente
    \item Enregistrer un paiement
    \item Vérifier la mise à jour du statut de la facture
    \item Vérifier la réception de l'email de confirmation de paiement
\end{enumerate}

\textbf{Résultat :} ✓ Réussi

\subsection{Tests de sécurité}

\subsubsection{Tests d'authentification}
\begin{itemize}
    \item Test d'accès aux endpoints protégés sans token → 401 Unauthorized
    \item Test d'accès avec token invalide → 401 Unauthorized
    \item Test d'accès avec token expiré → 401 Unauthorized
    \item Test d'accès admin avec token user → 403 Forbidden
\end{itemize}

\textbf{Résultat :} Tous les tests réussis ✓

\subsubsection{Tests de validation des entrées}
\begin{itemize}
    \item Injection SQL (prévendue par JPA/PreparedStatements) → Bloqué ✓
    \item XSS dans les champs texte → Échappement automatique ✓
    \item Données invalides (email malformé, date passée) → Validées et rejetées ✓
\end{itemize}

\section{Tests de Performance}

\subsection{Tests de charge}

Des tests de charge basiques ont été réalisés pour évaluer la capacité du système :

\textbf{Configuration de test :}
\begin{itemize}
    \item Outil : JMeter
    \item Scénario : Création de rendez-vous
    \item Nombre d'utilisateurs virtuels : 100 simultanés
    \item Durée : 5 minutes
\end{itemize}

\textbf{Résultats :}
\begin{itemize}
    \item \textbf{Throughput :} 150 requêtes/seconde en moyenne
    \item \textbf{Temps de réponse moyen :} 250 ms
    \item \textbf{Temps de réponse 95e percentile :} 500 ms
    \item \textbf{Taux d'erreur :} < 0.5\%
\end{itemize}

\textbf{Conclusion :} Les performances sont satisfaisantes pour l'utilisation prévue.

\section{Résultats et Métriques}

\subsection{Synthèse des tests}

\begin{table}[H]
\centering
\caption{Synthèse des résultats de tests}
\label{tab:test-summary}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Type de test} & \textbf{Nombre} & \textbf{Réussis} & \textbf{Taux de réussite} \\
\hline
Tests unitaires & 128 & 128 & 100\% \\
\hline
Tests d'intégration & 45 & 45 & 100\% \\
\hline
Tests de résilience & 12 & 12 & 100\% \\
\hline
Tests manuels & 15 & 15 & 100\% \\
\hline
\textbf{Total} & \textbf{200} & \textbf{200} & \textbf{100\%} \\
\hline
\end{tabular}
\end{table}

\subsection{Bugs identifiés et corrigés}

Au cours des tests, plusieurs bugs ont été identifiés et corrigés :

\begin{enumerate}
    \item \textbf{Bug} : Circuit Breaker ne se déclenchait pas correctement
    \textbf{Cause} : Configuration du seuil incorrecte
    \textbf{Solution} : Ajustement de la configuration Resilience4j
    
    \item \textbf{Bug} : Emails non envoyés si RabbitMQ temporairement indisponible
    \textbf{Cause} : Pas de persistance des messages
    \textbf{Solution} : Configuration de la durabilité des queues RabbitMQ
    
    \item \textbf{Bug} : Factures générées en double pour le même rendez-vous
    \textbf{Cause} : Pas de vérification d'existence avant création
    \textbf{Solution} : Ajout d'un contrôle d'unicité sur rdvId
\end{enumerate}

\section{Conclusion}

Ce chapitre a présenté la stratégie de tests complète mise en œuvre pour garantir la qualité du système. Avec plus de 200 tests couvrant les aspects unitaires, d'intégration, de résilience et de sécurité, nous avons validé le bon fonctionnement du système.

Les tests de résilience ont confirmé l'efficacité des patterns Circuit Breaker, Retry et Timeout pour garantir la disponibilité du système même en cas de défaillance partielle. Les tests de sécurité ont validé la protection des endpoints et des données sensibles.

Les performances mesurées sont satisfaisantes pour l'utilisation prévue, avec des temps de réponse inférieurs à 500 ms pour 95\% des requêtes.

Le chapitre suivant discutera les résultats obtenus et proposera une analyse critique du système réalisé.
